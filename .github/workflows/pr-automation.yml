name: PR Automation

on:
  workflow_call:
    secrets:
      ANTHROPIC_API_KEY:
        required: false
      MOONSHOT_API_KEY:
        required: false
      OPENAI_API_KEY:
        required: false
  issue_comment:
    types: [created]
  pull_request:
    types: [opened]

jobs:
  setup:
    if: |
      (github.event_name == 'issue_comment' &&
       github.event.issue.pull_request &&
       (startsWith(github.event.comment.body, '[action]') ||
        startsWith(github.event.comment.body, '[fix]') ||
        startsWith(github.event.comment.body, '[debug]'))) ||
      (github.event_name == 'pull_request' &&
       (contains(github.event.pull_request.body, '[action]') ||
        contains(github.event.pull_request.body, '[fix]') ||
        contains(github.event.pull_request.body, '[debug]')))

    runs-on: ubuntu-latest

    permissions:
      statuses: write
      pull-requests: read

    outputs:
      branch: ${{ steps.pr.outputs.branch }}
      sha: ${{ steps.pr.outputs.sha }}
      pr_number: ${{ steps.pr.outputs.pr_number }}
      command: ${{ steps.pr.outputs.command }}
      instructions: ${{ steps.pr.outputs.instructions }}

    steps:
      - name: Get PR details and set pending status
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            let prData, body, prNumber;

            if (context.eventName === 'pull_request') {
              prData = context.payload.pull_request;
              body = prData.body || '';
              prNumber = prData.number;
            } else {
              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });
              prData = pr.data;
              body = context.payload.comment.body;
              prNumber = context.issue.number;
            }

            const sha = prData.head.sha;
            core.setOutput('branch', prData.head.ref);
            core.setOutput('sha', sha);
            core.setOutput('pr_number', prNumber);

            let command = 'unknown';
            let instructions = '';

            if (context.eventName === 'pull_request') {
              if (body.includes('[action]')) {
                command = 'action';
                const match = body.match(/\[action\](.*?)(?=\[(?:action|fix|debug)\]|$)/s);
                instructions = match ? match[1].trim() : '';
              } else if (body.includes('[fix]')) {
                command = 'fix';
                const match = body.match(/\[fix\](.*?)(?=\[(?:action|fix|debug)\]|$)/s);
                instructions = match ? match[1].trim() : '';
              } else if (body.includes('[debug]')) {
                command = 'debug';
              }
            } else {
              if (body.startsWith('[action]')) {
                command = 'action';
                instructions = body.slice('[action]'.length).trim();
              } else if (body.startsWith('[fix]')) {
                command = 'fix';
                instructions = body.slice('[fix]'.length).trim();
              } else if (body.startsWith('[debug]')) {
                command = 'debug';
              }
            }

            core.setOutput('command', command);
            core.setOutput('instructions', instructions);

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: sha,
              state: 'pending',
              context: `PR Automation / ${command}`,
              description: 'Waiting for runner...',
              target_url: `${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            });

  execute:
    needs: setup
    runs-on: ${{ vars.RUNNER_TYPE || 'ubuntu-latest' }}

    permissions:
      contents: write
      pull-requests: write
      statuses: write

    env:
      AGENT_TYPE: ${{ vars.AGENT_TYPE || 'claude' }}
      AGENT_MODEL: ${{ vars.AGENT_MODEL || vars.CLAUDE_MODEL || '' }}

    steps:
      - name: Update status to running
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: '${{ needs.setup.outputs.sha }}',
              state: 'pending',
              context: 'PR Automation / ${{ needs.setup.outputs.command }}',
              description: 'Running (${{ vars.AGENT_TYPE || 'claude' }})...',
              target_url: '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
            });

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.branch }}
          fetch-depth: 0

      - name: Checkout run-agent.sh from pr-resolver
        uses: actions/checkout@v4
        with:
          repository: GiggleLiu/pr-resolver
          path: .pr-resolver
          sparse-checkout: run-agent.sh
          sparse-checkout-cone-mode: false

      - name: Make run-agent.sh executable
        run: chmod +x .pr-resolver/run-agent.sh

      - name: Setup Node.js (GitHub-hosted, claude agent)
        if: vars.RUNNER_TYPE != 'self-hosted' && (vars.AGENT_TYPE || 'claude') == 'claude'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Claude Code CLI (GitHub-hosted, claude agent)
        if: vars.RUNNER_TYPE != 'self-hosted' && (vars.AGENT_TYPE || 'claude') == 'claude'
        run: npm install -g @anthropic-ai/claude-code

      - name: Install superpowers plugin (GitHub-hosted, claude agent)
        if: vars.RUNNER_TYPE != 'self-hosted' && (vars.AGENT_TYPE || 'claude') == 'claude'
        run: claude plugin install anthropics/claude-code-superpowers

      - name: Install OpenCode CLI (GitHub-hosted, opencode agent)
        if: vars.RUNNER_TYPE != 'self-hosted' && (vars.AGENT_TYPE || 'claude') == 'opencode'
        run: curl -fsSL https://opencode.ai/install.sh | bash

      - name: Acquire credentials
        env:
          ANTHROPIC_API_KEY_SECRET: ${{ secrets.ANTHROPIC_API_KEY }}
          MOONSHOT_API_KEY_SECRET: ${{ secrets.MOONSHOT_API_KEY }}
          OPENAI_API_KEY_SECRET: ${{ secrets.OPENAI_API_KEY }}
        run: |
          case "$AGENT_TYPE" in
            claude)
              # Use API key from secret if available
              if [ -n "$ANTHROPIC_API_KEY_SECRET" ]; then
                echo "::add-mask::$ANTHROPIC_API_KEY_SECRET"
                echo "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY_SECRET" >> $GITHUB_ENV
                echo "Using API key from secret"
                exit 0
              fi

              # Self-hosted: read OAuth from token file (written by make start)
              TOKEN_FILE="$HOME/.claude-oauth-token"
              if [ -f "$TOKEN_FILE" ]; then
                ACCESS_TOKEN=$(cat "$TOKEN_FILE" 2>/dev/null)
                if [ -n "$ACCESS_TOKEN" ] && [ "$ACCESS_TOKEN" != "null" ]; then
                  echo "::add-mask::$ACCESS_TOKEN"
                  echo "CLAUDE_CODE_OAUTH_TOKEN=$ACCESS_TOKEN" >> $GITHUB_ENV
                  echo "OAuth token acquired from token file"
                  exit 0
                fi
              fi

              # Self-hosted Linux: read from credentials file
              if [ -f ~/.claude/.credentials.json ]; then
                ACCESS_TOKEN=$(jq -r '.claudeAiOauth.accessToken' ~/.claude/.credentials.json 2>/dev/null)
                if [ -n "$ACCESS_TOKEN" ] && [ "$ACCESS_TOKEN" != "null" ]; then
                  echo "::add-mask::$ACCESS_TOKEN"
                  echo "CLAUDE_CODE_OAUTH_TOKEN=$ACCESS_TOKEN" >> $GITHUB_ENV
                  echo "OAuth token acquired from credentials file"
                  exit 0
                fi
              fi

              echo "Error: No Claude credentials available (need ANTHROPIC_API_KEY secret or OAuth login)"
              exit 1
              ;;

            opencode)
              # Self-hosted: providers pre-configured via opencode /connect
              if [ -f "$HOME/.local/share/opencode/auth.json" ] || [ -f "$HOME/.config/opencode/opencode.json" ]; then
                echo "Using pre-configured OpenCode providers"
                exit 0
              fi

              # GitHub-hosted: pass API key from secret as env var
              if [ -n "$MOONSHOT_API_KEY_SECRET" ]; then
                echo "::add-mask::$MOONSHOT_API_KEY_SECRET"
                echo "MOONSHOT_API_KEY=$MOONSHOT_API_KEY_SECRET" >> $GITHUB_ENV
                echo "Using Moonshot API key from secret"
              elif [ -n "$OPENAI_API_KEY_SECRET" ]; then
                echo "::add-mask::$OPENAI_API_KEY_SECRET"
                echo "OPENAI_API_KEY=$OPENAI_API_KEY_SECRET" >> $GITHUB_ENV
                echo "Using OpenAI API key from secret"
              else
                echo "Error: No OpenCode credentials available (need MOONSHOT_API_KEY or OPENAI_API_KEY secret)"
                exit 1
              fi
              ;;

            *)
              echo "Error: Unknown AGENT_TYPE '$AGENT_TYPE'. Supported: claude, opencode"
              exit 1
              ;;
          esac

      - name: Find plan file
        id: plan
        if: needs.setup.outputs.command == 'action'
        run: |
          # Priority 1: well-known fixed paths
          for f in PLAN.md plan.md .claude/plan.md docs/plan.md; do
            [ -f "$f" ] && echo "file=$f" >> $GITHUB_OUTPUT && exit 0
          done

          # Priority 2: plan file changed in this PR branch
          changed=$(git diff --name-only --diff-filter=AM origin/main...HEAD -- 'docs/plans/*.md' 2>/dev/null | tail -1)
          [ -n "$changed" ] && [ -f "$changed" ] && echo "file=$changed" >> $GITHUB_OUTPUT && exit 0

          # Priority 3: most recently committed plan file
          latest=$(git log --diff-filter=AM --name-only --pretty=format: -- 'docs/plans/*.md' 2>/dev/null | grep -m1 '\.md$')
          [ -n "$latest" ] && [ -f "$latest" ] && echo "file=$latest" >> $GITHUB_OUTPUT && exit 0

          echo "No plan file found" && exit 1

      - name: Build action prompt
        id: action-prompt
        if: needs.setup.outputs.command == 'action'
        env:
          INSTRUCTIONS: ${{ needs.setup.outputs.instructions }}
          PLAN_FILE: ${{ steps.plan.outputs.file }}
          BRANCH: ${{ needs.setup.outputs.branch }}
          PR_NUMBER: ${{ needs.setup.outputs.pr_number }}
          REPO: ${{ github.repository }}
        run: |

          if [ "$AGENT_TYPE" = "claude" ]; then
            PROCESS="1. Read the plan file
          2. Use /subagent-driven-development to execute tasks
          3. Push: git push origin $BRANCH
          4. Post summary: gh pr comment $PR_NUMBER --repo $REPO --body 'SUMMARY'"
          else
            PROCESS="1. Read the plan file
          2. Execute the tasks step by step. For each task, implement and test before moving on.
          3. Push: git push origin $BRANCH
          4. Post summary: gh pr comment $PR_NUMBER --repo $REPO --body 'SUMMARY'"
          fi

          {
            echo 'prompt<<PROMPT_EOF'
            echo "Execute the plan in '$PLAN_FILE'."
            if [ -n "$INSTRUCTIONS" ]; then
              echo ""
              echo "## Additional Instructions"
              echo "$INSTRUCTIONS"
            fi
            echo ""
            echo "## Process"
            echo "$PROCESS"
            echo ""
            echo "## Rules"
            echo "- Tests should be strong enough to catch regressions."
            echo "- Do not modify tests to make them pass."
            echo "- Test failure must be reported."
            echo 'PROMPT_EOF'
          } >> $GITHUB_OUTPUT

      - name: Execute plan
        if: needs.setup.outputs.command == 'action'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PROMPT: ${{ steps.action-prompt.outputs.prompt }}
        run: |
          set -eo pipefail
          .pr-resolver/run-agent.sh "$AGENT_TYPE" "$AGENT_MODEL" "$PROMPT"

      - name: Build fix prompt
        id: fix-prompt
        if: needs.setup.outputs.command == 'fix'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          INSTRUCTIONS: ${{ needs.setup.outputs.instructions }}
          BRANCH: ${{ needs.setup.outputs.branch }}
          PR_NUMBER: ${{ needs.setup.outputs.pr_number }}
          REPO: ${{ github.repository }}
        run: |
          # Gather all feedback sources
          INLINE=$(gh api "repos/$REPO/pulls/$PR_NUMBER/comments" --jq '.[].body' 2>/dev/null || echo "")
          REVIEWS=$(gh api "repos/$REPO/pulls/$PR_NUMBER/reviews" --jq '.[] | select(.body != "") | .body' 2>/dev/null || echo "")
          PR_COMMENTS=$(gh api "repos/$REPO/issues/$PR_NUMBER/comments" --jq '.[].body' 2>/dev/null || echo "")

          # Gather CI status
          CI_STATUS=$(gh pr checks "$PR_NUMBER" --repo "$REPO" 2>/dev/null || echo "")
          FAILED_RUNS=$(gh run list --branch "$BRANCH" --status failure --limit 3 --json databaseId,name --jq '.[] | "\(.databaseId) \(.name)"' 2>/dev/null || echo "")

          # Get failed run logs if any
          CI_LOGS=""
          for run_id in $(echo "$FAILED_RUNS" | cut -d' ' -f1); do
            [ -n "$run_id" ] && CI_LOGS="$CI_LOGS
          --- Run $run_id ---
          $(gh run view $run_id --log-failed 2>/dev/null | tail -100 || echo 'Could not fetch logs')"
          done

          if [ "$AGENT_TYPE" = "claude" ]; then
            DEBUG_STEP="1. Use /systematic-debugging if CI failed"
          else
            DEBUG_STEP="1. Analyze CI failure logs to identify root causes"
          fi

          {
            echo 'prompt<<PROMPT_EOF'
            echo "Fix all issues with this PR: review comments AND CI failures."
            if [ -n "$INSTRUCTIONS" ]; then
              echo ""
              echo "## Additional Instructions"
              echo "$INSTRUCTIONS"
            fi
            echo ""
            echo "=== Inline Code Comments ==="
            echo "$INLINE"
            echo ""
            echo "=== PR Reviews ==="
            echo "$REVIEWS"
            echo ""
            echo "=== PR Conversation ==="
            echo "$PR_COMMENTS"
            echo ""
            echo "=== CI Status ==="
            echo "$CI_STATUS"
            echo ""
            echo "=== Failed CI Logs (last 100 lines each) ==="
            echo "$CI_LOGS"
            echo ""
            echo "## Process"
            echo "$DEBUG_STEP"
            echo "2. Fix review comments and CI issues"
            echo "3. Run tests to verify: make test, cargo test, npm test, etc."
            echo "4. Commit: git commit -am 'Fix review feedback and CI issues'"
            echo "5. Push: git push origin $BRANCH"
            echo "6. Post summary: gh pr comment $PR_NUMBER --repo $REPO --body 'SUMMARY'"
            echo ""
            echo "## Rules"
            echo "- All CI failures must be fixed."
            echo "- All change requests must be either addressed or explained."
            echo 'PROMPT_EOF'
          } >> $GITHUB_OUTPUT

      - name: Fix issues
        if: needs.setup.outputs.command == 'fix'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PROMPT: ${{ steps.fix-prompt.outputs.prompt }}
        run: |
          set -eo pipefail
          .pr-resolver/run-agent.sh "$AGENT_TYPE" "$AGENT_MODEL" "$PROMPT"

      - name: Debug test
        if: needs.setup.outputs.command == 'debug'
        run: |
          echo "Debug test passed - workflow is working (agent: $AGENT_TYPE)" | tee claude-output.txt

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: claude-output
          path: claude-output.txt
          retention-days: 7

      - name: Set success status
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: '${{ needs.setup.outputs.sha }}',
              state: 'success',
              context: 'PR Automation / ${{ needs.setup.outputs.command }}',
              description: 'Completed successfully',
              target_url: '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
            });

      - name: Set failure status
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: '${{ needs.setup.outputs.sha }}',
              state: 'failure',
              context: 'PR Automation / ${{ needs.setup.outputs.command }}',
              description: 'Failed - check logs',
              target_url: '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
            });
